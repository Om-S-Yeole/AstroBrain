from typing import TypedDict

import numpy as np

from app.core.mission.communication import CommunicationResults
from app.core.mission.eclipse import EclipseResults
from app.core.mission.power import PowerResults
from app.core.mission.propagator import PropagationResults


class PayloadConfig(TypedDict):
    payload_power_W: float
    data_rate_Mbps: float  # data generated when ON
    duty_cycle: float  # 0–1 (fraction of time ON)
    requires_sunlight: bool
    requires_contact: bool


class DutyCycleResults(TypedDict):
    power_feasible: bool
    sunlight_feasible: bool
    downlink_feasible: bool
    overall_feasible: bool
    data_generated_Mb: float
    data_downlinked_Mb: float
    limiting_factor: str


def compute_payload_ON_time(times: list | np.ndarray, duty_cycle: float) -> float:
    """
    Calculate the total time the payload is operating (ON) during the mission.

    Parameters
    ----------
    times : list or np.ndarray
        Array of datetime objects representing the mission timeline.
    duty_cycle : float
        Fraction of time the payload is ON, range 0-1 (dimensionless).

    Returns
    -------
    float
        Total payload ON time in seconds.
    """
    return duty_cycle * (max(times) - min(times)).total_seconds()


def check_sunlight_constraint(
    times: np.ndarray,
    eclipse_windows: list[dict],
    duty_cycle: float,
) -> bool:
    """
    Verify if there is sufficient sunlight time to meet the payload duty cycle.

    This function checks whether the total time spent in sunlight (not in eclipse)
    is sufficient to accommodate the required payload operating time based on the
    specified duty cycle.

    Parameters
    ----------
    times : np.ndarray
        Array of datetime objects representing the mission timeline.
    eclipse_windows : list of dict
        List of eclipse window dictionaries, each containing:
        - 'start': eclipse start time (datetime)
        - 'end': eclipse end time (datetime)
        - 'duration': eclipse duration in seconds (float)
    duty_cycle : float
        Fraction of mission time the payload must be ON, range 0-1 (dimensionless).

    Returns
    -------
    bool
        True if sufficient sunlight time is available to meet the duty cycle
        requirement, False otherwise.

    Notes
    -----
    The function compares:
    - Required ON time = total_mission_time × duty_cycle
    - Available sunlight time = total_mission_time - total_eclipse_time

    Returns True if available sunlight time ≥ required ON time.
    """
    total_mission_time = (max(times) - min(times)).total_seconds()

    total_eclipse_time = 0
    for window in eclipse_windows:
        total_eclipse_time += window["duration"]

    t_ON_required = total_mission_time * duty_cycle
    t_sunlit = total_mission_time - total_eclipse_time

    return t_sunlit >= t_ON_required


def compute_data_generated(on_time_s: float, data_rate_Mbps: float) -> float:
    """
    Calculate the total data generated by the payload during operation.

    Parameters
    ----------
    on_time_s : float
        Total time the payload is ON in seconds.
    data_rate_Mbps : float
        Data generation rate when payload is ON, in megabits per second (Mbps).

    Returns
    -------
    float
        Total data generated in megabits (Mb).
    """
    return on_time_s * data_rate_Mbps


def compute_data_downlinked(
    communication_results: CommunicationResults, downlink_rate_Mbps: float
) -> float:
    """
    Calculate the total data that can be downlinked during available contact windows.

    Parameters
    ----------
    communication_results : CommunicationResults
        Dictionary containing communication analysis results with key:
        - 'total_contact_time': cumulative ground station contact time in seconds (float)
    downlink_rate_Mbps : float
        Data downlink rate in megabits per second (Mbps).

    Returns
    -------
    float
        Total data that can be downlinked in megabits (Mb).
    """
    return communication_results["total_contact_time"] * downlink_rate_Mbps


def evaluate_duty_cycle(
    propagation_results: PropagationResults,
    eclipse_results: EclipseResults,
    power_results: PowerResults,
    communication_results: CommunicationResults,
    payload_config: PayloadConfig,
    downlink_rate_Mbps: float,
) -> dict:
    """
    Evaluate the feasibility of a payload duty cycle considering all mission constraints.

    This function performs a comprehensive analysis of whether the specified payload
    duty cycle is achievable given power, sunlight, and downlink constraints. It
    identifies the limiting factor if the duty cycle is not feasible.

    Parameters
    ----------
    propagation_results : PropagationResults
        Dictionary containing spacecraft trajectory data with key:
        - 'time': list of datetime objects for the mission timeline (list[datetime])
    eclipse_results : EclipseResults
        Dictionary containing eclipse analysis results with key:
        - 'windows': list of eclipse window dictionaries with duration information (list[dict])
    power_results : PowerResults
        Dictionary containing power budget analysis with key:
        - 'power_violation': boolean indicating if battery SOC reached zero (bool)
    communication_results : CommunicationResults
        Dictionary containing communication analysis with key:
        - 'total_contact_time': cumulative contact time with ground stations in seconds (float)
    payload_config : PayloadConfig
        Payload configuration dictionary containing:
        - 'duty_cycle': fraction of time payload is ON, range 0-1 (float)
        - 'payload_power_W': power consumption when ON in watts (float)
        - 'data_rate_Mbps': data generation rate when ON in Mbps (float)
        - 'requires_sunlight': whether payload can only operate in sunlight (bool)
        - 'requires_contact': whether data must be downlinked (bool)
    downlink_rate_Mbps : float
        Data downlink rate to ground stations in megabits per second (Mbps).

    Returns
    -------
    DutyCycleResults
        Dictionary containing duty cycle evaluation results:
        - 'power_feasible': True if power budget supports duty cycle (bool)
        - 'sunlight_feasible': True if sunlight availability supports duty cycle (bool)
        - 'downlink_feasible': True if downlink capacity can handle generated data (bool)
        - 'overall_feasible': True if all constraints are satisfied (bool)
        - 'data_generated_Mb': total data generated during mission in megabits (float)
        - 'data_downlinked_Mb': total data that can be downlinked in megabits (float)
        - 'limiting_factor': identifies the constraint limiting feasibility:
          'power', 'sunlight', 'downlink', or 'none' (str)

    Raises
    ------
    ValueError
        If duty_cycle is not in the range [0, 1].

    Notes
    -----
    Feasibility Checks:
    1. **Power feasibility**: Checks if battery SOC never reaches zero during
       the mission, indicating sufficient power for the duty cycle.

    2. **Sunlight feasibility**: Only relevant if payload requires sunlight
       (payload_config['requires_sunlight'] = True). Verifies that total time
       in sunlight ≥ required payload ON time.

    3. **Downlink feasibility**: Only relevant if data must be downlinked
       (payload_config['requires_contact'] = True). Checks if downlink capacity
       during ground contact windows ≥ total data generated.

    Limiting Factor Priority:
    - Identifies the first failed constraint in order: power → sunlight → downlink
    - Returns 'none' if all constraints are satisfied

    Applications:
    - Mission planning: assess payload operational feasibility
    - Trade studies: optimize duty cycle vs. data collection requirements
    - Design validation: verify spacecraft meets payload operation requirements
    - Operations: plan payload scheduling within available resources
    """
    if not 0 <= payload_config["duty_cycle"] <= 1:
        raise ValueError(
            f"Duty cycle must be in [0, 1]. Got {payload_config['duty_cycle']}"
        )

    power_feasible = not power_results["power_violation"]

    times = propagation_results["time"]
    duty_cycle = payload_config["duty_cycle"]
    sunlight_feasible = (
        True
        if not payload_config["requires_sunlight"]
        else check_sunlight_constraint(times, eclipse_results["windows"], duty_cycle)
    )

    data_rate_Mbps = payload_config["data_rate_Mbps"]

    on_time = compute_payload_ON_time(times, duty_cycle)

    data_generated = compute_data_generated(on_time, data_rate_Mbps)
    data_downlinked = compute_data_downlinked(communication_results, downlink_rate_Mbps)

    downlink_feasible = (
        True
        if not payload_config["requires_contact"]
        else data_generated <= data_downlinked
    )

    overall_feasible = power_feasible and downlink_feasible and sunlight_feasible

    limiting_factor = ""
    if not power_feasible:
        limiting_factor = "power"
    elif not sunlight_feasible:
        limiting_factor = "sunlight"
    elif not downlink_feasible:
        limiting_factor = "downlink"
    else:
        limiting_factor = "none"

    return {
        "power_feasible": power_feasible,
        "sunlight_feasible": sunlight_feasible,
        "downlink_feasible": downlink_feasible,
        "overall_feasible": overall_feasible,
        "data_generated_Mb": data_generated,
        "data_downlinked_Mb": data_downlinked,
        "limiting_factor": limiting_factor,
    }
