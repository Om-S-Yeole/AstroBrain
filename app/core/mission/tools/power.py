import numpy as np
import pytz
from langchain.tools import tool
from pydantic import BaseModel

from app.core.mission.utils.eclipse import EclipseResults
from app.core.mission.utils.power import (
    PowerConfig,
    PowerResults,
    compute_power_consumption,
    compute_power_generation,
    propagate_battery_soc,
)
from app.core.mission.utils.propagator import PropagationResults


class ComputePowerGenerationTool(BaseModel):
    model_config = {"arbitrary_types_allowed": True}
    power_config: PowerConfig


class ComputePowerConsumptionTool(BaseModel):
    model_config = {"arbitrary_types_allowed": True}
    power_config: PowerConfig


class PropagateBatterySocTool(BaseModel):
    model_config = {"arbitrary_types_allowed": True}
    times: list | np.ndarray
    eclipsed: list | np.ndarray
    power_config: PowerConfig


class ComputePowerBudgetTool(BaseModel):
    model_config = {"arbitrary_types_allowed": True}
    propagation_results: PropagationResults
    eclipse_results: EclipseResults
    power_config: PowerConfig


SOLAR_CONSTANT = 1361  # W / m^2


@tool(args_schema=ComputePowerGenerationTool)
def compute_power_generation_tool(power_config: PowerConfig) -> float:
    """
    Calculate the power generated by solar panels in full sunlight.

    Uses the solar constant, panel area, and efficiency to determine
    maximum power generation when not in eclipse.

    Parameters
    ----------
    power_config : PowerConfig
        Configuration dictionary containing:
        - 'solar_panel_area_m2': solar panel area in square meters (float)
        - 'solar_efficiency': solar panel efficiency as fraction 0-1 (float)

    Returns
    -------
    float
        Power generation in watts (W).
    """
    # In watts
    return (
        power_config["solar_panel_area_m2"]
        * power_config["solar_efficiency"]
        * SOLAR_CONSTANT
    )


@tool(args_schema=ComputePowerConsumptionTool)
def compute_power_consumption_tool(power_config: PowerConfig) -> float:
    """
    Calculate the total power consumption of the spacecraft.

    Sums the bus power and payload power to determine total continuous
    power draw.

    Parameters
    ----------
    power_config : PowerConfig
        Configuration dictionary containing:
        - 'bus_power_W': spacecraft bus power consumption in watts (float)
        - 'payload_power_W': payload power consumption in watts (float)

    Returns
    -------
    float
        Total power consumption in watts (W).
    """
    return power_config["bus_power_W"] + power_config["payload_power_W"]


@tool(args_schema=PropagateBatterySocTool)
def propagate_battery_soc_tool(
    times: list | np.ndarray,
    eclipsed: list | np.ndarray,
    power_config: PowerConfig,
) -> np.ndarray:
    """
    Propagate battery state of charge (SOC) over time.

    Simulates battery charging (in sunlight) and discharging (continuous consumption)
    throughout the orbit. SOC is clamped between 0 and 1.

    Parameters
    ----------
    times : list or np.ndarray
        Array of datetime objects for each time step.
    eclipsed : list or np.ndarray
        Boolean array indicating eclipse status at each time step.
    power_config : PowerConfig
        Configuration dictionary containing:
        - 'initial_soc': initial state of charge, range 0-1 (float)
        - 'battery_capacity_Wh': battery capacity in watt-hours (float)
        - 'solar_panel_area_m2': solar panel area in square meters (float)
        - 'solar_efficiency': solar panel efficiency, range 0-1 (float)
        - 'bus_power_W': bus power consumption in watts (float)
        - 'payload_power_W': payload power consumption in watts (float)

    Returns
    -------
    np.ndarray
        Array of state of charge values (0-1) at each time step.

    Raises
    ------
    TypeError
        If times or eclipsed are not list or numpy arrays.
    ValueError
        If initial_soc is not in the range [0, 1].
    """
    if not isinstance(times, (list, np.ndarray)):
        raise TypeError(
            f"Expected type of times is list or np.ndarray. Got {type(times)}"
        )
    if not isinstance(eclipsed, (list, np.ndarray)):
        raise TypeError(
            f"Expected type of eclipsed is list or np.ndarray. Got {type(eclipsed)}"
        )
    if not 0 <= power_config["initial_soc"] <= 1:
        raise ValueError("initial_soc must be in [0, 1]")

    power_consumption = compute_power_consumption(power_config)
    power_generation = compute_power_generation(power_config)

    propagated_soc = [power_config["initial_soc"]]
    curr_soc = power_config["initial_soc"]
    prev_datetime = times[0].replace(tzinfo=pytz.utc)

    for time, is_eclipsed in zip(times[1:], eclipsed[1:]):
        p_net = (0 if is_eclipsed else power_generation) - power_consumption
        seconds = (time.replace(tzinfo=pytz.utc) - prev_datetime).total_seconds()
        curr_soc += (p_net * seconds) / (3600 * power_config["battery_capacity_Wh"])
        curr_soc = max(0.0, min(curr_soc, 1.0))
        propagated_soc.append(curr_soc)
        prev_datetime = time

    return np.array(propagated_soc)


@tool(args_schema=ComputePowerBudgetTool)
def compute_power_budget_tool(
    propagation_results: PropagationResults,
    eclipse_results: EclipseResults,
    power_config: PowerConfig,
) -> PowerResults:
    """
    Compute the power budget for an entire orbit propagation.

    Analyzes the spacecraft power generation and consumption throughout the
    orbit to determine battery state of charge evolution and identify any
    power violations.

    Parameters
    ----------
    propagation_results : PropagationResults
        Dictionary containing propagation data with key:
        - 'time': list of datetime objects
    eclipse_results : EclipseResults
        Dictionary containing eclipse data with key:
        - 'eclipsed': boolean array indicating eclipse status
    power_config : PowerConfig
        Configuration dictionary containing power system parameters:
        - 'battery_capacity_Wh': battery capacity in watt-hours (float)
        - 'initial_soc': initial state of charge, range 0-1 (float)
        - 'solar_panel_area_m2': solar panel area in square meters (float)
        - 'solar_efficiency': solar panel efficiency, range 0-1 (float)
        - 'bus_power_W': bus power consumption in watts (float)
        - 'payload_power_W': payload power consumption in watts (float)

    Returns
    -------
    PowerResults
        TypedDict containing:
        - 'soc': array of state of charge values at each time step
        - 'min_soc': minimum state of charge reached (float)
        - 'power_violation': True if SOC reached 0, False otherwise (bool)
        - 'final_soc': final state of charge at end of propagation (float)
    """
    times = propagation_results["time"]
    eclipsed = eclipse_results["eclipsed"]

    soc_arr = propagate_battery_soc(times, eclipsed, power_config)
    min_soc = np.min(soc_arr)
    power_violation = min_soc <= 0
    final_soc = soc_arr[-1]

    return {
        "soc": soc_arr,
        "min_soc": min_soc,
        "power_violation": power_violation,
        "final_soc": final_soc,
    }
